record(mbbi, "$(P)PortStatus")
{
    info(archive, "Monitor, 00:01:00")
    field(DESC, "Status of OccPortDriver")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(FLNK, "$(P)StatusCalc")
    field(INP,  "@asyn($(PORT))Status")
    field(ZRVL, "0")
    field(ZRST, "OK")
    field(ONVL, "1")
    field(ONST, "RX buffer full")
    field(ONSV, "MAJOR")
    field(TWVL, "2")
    field(TWST, "OCC error")
    field(TWSV, "MAJOR")
    field(THVL, "3")
    field(THST, "Corrupted data")
    field(THSV, "MAJOR")
    field(FRVL, "4")
    field(FRST, "Resetting")
    field(FVVL, "5")
    field(FVST, "OCC no init")
    field(FVSV, "MAJOR")
    field(UNSV, "MINOR")
    field(SCAN, "I/O Intr")
}
record(mbbo, "$(P)Command")
{
    field(ASG,  "BEAMLINE")
    field(DESC, "Issue OccPortDriver command")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))Command")
    field(ZRVL, "0")
    field(ZRST, "None")
    field(ONVL, "1")
    field(ONST, "Reset")
}
record(mbbi, "$(P)LastErr")
{
    field(DESC, "Last error returned from OCC library")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))LastErr")
    # Those match to return code of occ_*() functions
    field(ZRVL, "0")
    field(ONVL, "1")  # EPERM
    field(TWVL, "2")  # ENOENT
    field(THVL, "42") # ENOMSG
    field(FRVL, "61") # ENODATA
    field(FVVL, "75") # EOVERFLOW
    field(SXVL, "104") # ECONNRESET
    field(ZRST, "No error")
    field(ONST, "Permission denied")
    field(TWST, "No device")
    field(THST, "Version mismatch")
    field(FRST, "Interface error")
    field(FVST, "Buffer full")
    field(SXST, "Device reset")
    field(SCAN, "I/O Intr")
}
record(mbbi, "$(P)HwType")
{
    field(DESC, "OCC board type")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))HwType")
    field(ONVL, "1")
    field(TWVL, "2")
    field(FFVL, "15")
    field(ONST, "SNS PCI-X")
    field(TWST, "SNS PCI Express")
    field(FFST, "Simulator")
}
record(stringin, "$(P)FpgaSn")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT))FpgaSn")
    field(PINI, "YES")
}
record(longin, "$(P)HwVer")
{
    info(archive, "Monitor, 00:01:00")
    field(DESC, "OCC board hardware version")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))HwVer")
}
record(longin, "$(P)FwVer")
{
    info(archive, "Monitor, 00:01:00")
    field(DESC, "OCC board firmware version")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))FwVer")
}
record(longin, "$(P)FwDate")
{
    info(archive, "Monitor, 00:01:00")
    field(DESC, "OCC board firmware date")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))FwDate")
}
record(mbbi, "$(P)ConStatus")
{
    info(archive, "Monitor, 00:01:00")
    field(DESC, "Optical signal status")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(FLNK, "$(P)StatusCalc")
    field(INP,  "@asyn($(PORT))ConStatus")
    field(SCAN, "I/O Intr")
    field(UNSV, "MINOR")
    field(ZRVL, "0")
    field(ZRST, "Connected")
    field(ONSV, "NO_ALARM")
    field(ONVL, "1")
    field(ONST, "No SFP")
    field(ONSV, "MAJOR")
    field(TWVL, "2")
    field(TWST, "No cable")
    field(TWSV, "MAJOR")
    field(THVL, "3")
    field(THST, "Laser fault")
    field(THSV, "MAJOR")
}
record(bo, "$(P)RxEn")
{
    info(autosaveFields, "VAL")
    field(ASG,  "BEAMLINE")
    field(DESC, "Enable incoming data")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))RxEn")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    field(PINI, "YES")
}
record(bi, "$(P)RxEnRb")
{
    field(DESC, "Incoming data enabled")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))RxEnRb")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
    field(SCAN, "I/O Intr")
}
record(bo, "$(P)ErrPktEn")
{
    info(autosaveFields, "VAL")
    field(ASG,  "BEAMLINE")
    field(DESC, "Error packets output switch")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))ErrPktEn")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
    field(VAL,  "0")
    field(PINI, "YES")
}
record(bi, "$(P)ErrPktEnRb")
{
    field(DESC, "Error packets output enabled")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))ErrPktEnRb")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
    field(SCAN, "I/O Intr")
}
record(mbbi, "$(P)RxStalled")
{
    info(archive, "Monitor, 00:01:00")
    field(DESC, "Incoming data stalled")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))RxStalled")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
    field(ZRVL, "0")
    field(ZRST, "Not stalled")
    field(ONVL, "1")
    field(ONST, "DMA stalled")
    field(ONSV, "MAJOR")
    field(TWVL, "2")
    field(TWST, "FIFO overflow")
    field(TWSV, "MAJOR")
    field(THVL, "3")
    field(THST, "Copy stalled")
    field(THSV, "MAJOR")
    field(UNSV, "MINOR")
}
record(ai, "$(P)FpgaTemp")
{
    info(archive, "Scan, 00:01:00")
    field(DESC, "FPGA temperature")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))FpgaTemp")
    field(EGU,  "Celsius")
    field(PREC, "2")
    field(HIGH, "60")
    field(HSV,  "MINOR")
    field(HIHI, "70")
    field(HHSV, "MAJOR")
    field(HYST, "2")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)FpgaTempAlarm")
}
record(calcout, "$(P)FpgaTempAlarm")
{
    field(DESC, "Take action on MAJOR alarm")
    field(INPA, "$(P)RxEn.RVAL NPP")
    field(INPB, "$(P)FpgaTemp.VAL NPP")
    field(INPC, "$(P)FpgaTemp.HIHI NPP")
    field(CALC, "(B>C)?0:A")
    field(OUT,  "$(P)RxEn PP")
    field(OOPT, "Transition to Zero")
}
record(ai, "$(P)FpgaCoreV")
{
    field(DESC, "FPGA core voltage")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))FpgaCoreV")
    field(EGU,  "Volt")
    field(PREC, "3")
    field(LOLO, "0.97")
    field(HIHI, "1.03")
    field(LLSV, "MAJOR")
    field(HHSV, "MAJOR")
    field(SCAN, "I/O Intr")
}
record(ai, "$(P)FpgaAuxV")
{
    field(DESC, "FPGA AUX voltage")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))FpgaAuxV")
    field(EGU,  "Volt")
    field(PREC, "3")
    field(LOLO, "1.71")
    field(HIHI, "1.89")
    field(LLSV, "MAJOR")
    field(HHSV, "MAJOR")
    field(SCAN, "I/O Intr")
}
record(mbbi, "$(P)SfpType")
{
    info(archive, "Monitor, 00:10:00")
    field(DESC, "SFP type")
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))SfpType")
    field(ZRVL, "0")
    field(ZRST, "Unknown")
    field(ONVL, "1")
    field(ONST, "Single mode")
    field(TWVL, "2")
    field(TWST, "Multi mode")
    field(UNSV, "MINOR")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)SfpTxPowerLim")
}
record(ai, "$(P)SfpTemp")
{
    info(archive, "Scan, 00:01:00")
    field(DESC, "SFP temperature")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))SfpTemp")
    field(EGU,  "Celsius")
    field(PREC, "2")
    field(HIGH, "60")
    field(HSV,  "MINOR")
    field(HIHI, "70")
    field(HYST, "2")
    field(SCAN, "I/O Intr")
}
record(ai, "$(P)SfpRxPower")
{
    info(archive, "Scan, 00:10:00")
    field(DESC, "SFP RX power")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))SfpRxPower")
    field(EGU,  "uW")
    field(PREC, "0")
    field(LOLO, "100")
    field(LLSV, "MAJOR")
    field(SCAN, "I/O Intr")
}
record(calcout, "$(P)SfpTxPowerLim")
{
    field(DESC, "Adjust SFP TX power low limit")
    field(INPA, "$(P)SfpType.RVAL NPP")
    field(CALC, "(A==1)?216:(A==2)?196:0") # Single mode specification 216uW, multi mode 216uW
    field(OUT,  "$(P)SfpTxPower.LOLO PP")
    field(OOPT, "On Change")
}
record(ai, "$(P)SfpTxPower")
{
    info(archive, "Scan, 00:10:00")
    field(DESC, "SFP TX power")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))SfpTxPower")
    field(EGU,  "uW")
    field(LOLO, "0") # Configured automatically by SfpTxPowerLim
    field(LLSV, "MAJOR")
    field(SCAN, "I/O Intr")
}
record(ai, "$(P)SfpVccPow")
{
    field(DESC, "SFP VCC power")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))SfpVccPow")
    field(EGU,  "Volt")
    field(PREC, "3")
    field(LOLO, "3.1")
    field(HIHI, "3.4")
    field(LLSV, "MAJOR")
    field(HHSV, "MAJOR")
    field(SCAN, "I/O Intr")
}
record(ai, "$(P)SfpTxBiasC")
{
    field(DESC, "SFP TX bias current")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT))SfpTxBiasC")
    field(EGU,  "uA")
    field(SCAN, "I/O Intr")
}
record(longin, "$(P)ErrCrc")
{
    field(DESC, "FPGA detected CRC errors counter")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))ErrCrc")
    field(SCAN, "I/O Intr")
}
record(longin, "$(P)ErrLength")
{
    field(DESC, "FPGA detected length errors counter")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))ErrLength")
    field(SCAN, "I/O Intr")
}
record(longin, "$(P)ErrFrame")
{
    field(DESC, "FPGA detected frame errors counter")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))ErrFrame")
    field(SCAN, "I/O Intr")
}
record(longin, "$(P)DmaUsed")
{
    field(DESC, "DMA buffer used space")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))DmaUsed")
    field(FLNK, "$(P)DmaUsedMb")
    field(SCAN, "I/O Intr")
    field(VAL,  "0")
    field(EGU,  "B")
}
record(calc, "$(P)DmaUsedMb")
{
    field(DESC, "DMA buffer used space")
    field(INPA, "$(P)DmaUsed NPP")
    field(CALC, "A/(1024*1024)")
    field(SCAN, "Passive")
    field(EGU,  "MB")
}
record(longin, "$(P)DmaSize")
{
    field(DESC, "DMA buffer total size")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))DmaSize")
    field(FLNK, "$(P)DmaSizeMb")
    field(SCAN, "Passive")
    field(PINI, "YES")
    field(EGU,  "B")
}
record(calc, "$(P)DmaSizeMb")
{
    field(DESC, "DMA buffer used space")
    field(INPA, "$(P)DmaSize NPP")
    field(CALC, "A/(1024*1024)")
    field(SCAN, "Passive")
    field(EGU,  "MB")
}
record(longin, "$(P)BufUsed")
{
    field(DESC, "Local buffer used space")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))BufUsed")
    field(FLNK, "$(P)BufUsedMb")
    field(SCAN, "I/O Intr")
    field(VAL,  "0")
    field(EGU,  "B")
}
record(calc, "$(P)BufUsedMb")
{
    field(DESC, "Local buffer used space")
    field(INPA, "$(P)BufUsed NPP")
    field(CALC, "A/(1024*1024)")
    field(SCAN, "Passive")
    field(EGU,  "MB")
}
record(longin, "$(P)BufSize")
{
    field(DESC, "Local buffer total size")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))BufSize")
    field(FLNK, "$(P)BufSizeMb")
    field(SCAN, "Passive")
    field(PINI, "YES")
    field(EGU,  "B")
}
record(calc, "$(P)BufSizeMb")
{
    field(DESC, "Local buffer used space")
    field(INPA, "$(P)BufSize NPP")
    field(CALC, "A/(1024*1024)")
    field(SCAN, "Passive")
    field(EGU,  "MB")
}
record(longout, "$(P)StatusInt")
{
    info(autosaveFields, "VAL")
    field(ASG,  "BEAMLINE")
    field(DESC, "Basic status update interval")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))StatusInt")
    field(EGU,  "seconds")
}
record(longout, "$(P)ExtStatInt")
{
    info(autosaveFields, "VAL")
    field(ASG,  "BEAMLINE")
    field(DESC, "Extended status update interval")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))ExtStatInt")
    field(EGU,  "seconds")
}
record(longin, "$(P)RxRateBs")
{
    field(DESC, "Data processing rate")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))RxRate")
    field(FLNK, "$(P)RxRateKBs")
    field(SCAN, "I/O Intr")
    field(VAL,  "0")
    field(EGU,  "B/s")
}
record(calc, "$(P)RxRateKBs")
{
    field(DESC, "Data processing rate")
    field(INPA, "$(P)RxRateBs NPP")
    field(FLNK, "$(P)RxRateMBs")
    field(CALC, "A/1024")
    field(SCAN, "Passive")
    field(EGU,  "KB/s")
    field(PREC, "1")
}
record(calc, "$(P)RxRateMBs")
{
    field(DESC, "Data processing rate")
    field(INPA, "$(P)RxRateKBs NPP")
    field(CALC, "A/1024")
    field(SCAN, "Passive")
    field(EGU,  "MB/s")
    field(PREC, "2")
}
record(bo, "$(P)AutoReset")
{
    info(autosaveFields, "VAL")
    field(ASG,  "BEAMLINE")
    field(DESC, "Automatic reset on any error")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))AutoReset")
    field(PINI, "YES")
    field(ZNAM, "disabled")
    field(ONAM, "enabled")
}
record(longin, "$(P)RstCntBad")
{
    field(DESC, "Num corrupted queue auto-resets")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))RstCntBad")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
}
record(longin, "$(P)RstCntOvr")
{
    field(DESC, "Num FIFO overflow auto-resets")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))RstCntOvr")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
}
record(longin, "$(P)RstCntDma")
{
    field(DESC, "Num DMA full auto-resets")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))RstCntDma")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
}
record(longin, "$(P)RstCntBuf")
{
    field(DESC, "Num buffer full auto-resets")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))RstCntBuf")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
}
record(longin, "$(P)RstCntErr")
{
    field(DESC, "Num OCC error auto-resets")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))RstCntBad")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
}
record(calcout, "$(P)StatusCalc")
{
    field(DESC, "Determine global OCC status")
    field(INPA, "$(P)Status NPP")
    field(INPB, "$(P)ConStatus NPP")
    field(PINI, "YES")
    field(CALC, "((A=0)&&(B=0))?1:0")
    field(OOPT, "Every Time")
    field(IVOA, "Don't drive outputs")
    field(OUT,  "$(P)Status PP")
}
record(bi, "$(P)Status")
{
    field(ASG,  "BEAMLINE")
    field(DESC, "Global OCC status")
    field(ZNAM, "Error")
    field(ONAM, "OK")
}
