record(bo, "$(P)Enable")
{
    info(autosaveFields, "VAL")
    field(PINI, "YES")
    field(FLNK, "$(P)StatusCalc")
}
record(stringin, "$(P)HwId")
{
    info(archive, "Monitor, 00:01:00, VAL")
    field(DESC, "Hardware ID address")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT))HwId")
    field(SCAN, "Passive")
    field(PINI, "YES")
}
record(mbbo, "$(P)CmdReq")
{
    field(ASG,  "BEAMLINE")
    field(DESC, "Send command to module")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))CmdReq")
    field(ZRVL, "128")
    field(ZRST, "Discover")
    field(ONVL, "32")
    field(ONST, "Read version")
    field(TWVL, "34")
    field(TWST, "Read status")
    field(THVL, "33")
    field(THST, "Read config")
    field(FRVL, "48")
    field(FRST, "Write config")
    field(FVVL, "130")
    field(FVST, "Start acquisition")
    field(SXVL, "131")
    field(SXST, "Stop acquisition")
    field(SVVL, "36")
    field(SVST, "Read counters")
    field(EIVL, "37")
    field(EIST, "Reset counters")
    field(NIVL, "35")
    field(NIST, "Read temperature")
    field(TEVL, "129")
    field(TEST, "Reset")
    field(ELVL, "39")
    field(ELST, "Reset LVDS")
    field(FLNK, "$(P)CmdReqDis")
}
# Force single outstanding operation at any time.
# put to CmdReq will fail until the response is received.
# CmdRsp will re-enable once received some response or timeout.
record(longout, "$(P)CmdReqDis")
{
    field(VAL,  "1")
    field(OUT,  "$(P)CmdReq.DISP")
}
record(longin, "$(P)CmdRspRaw")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))CmdRsp")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)CmdRspCalc")
}
# Only process CmdRsp while CmdReq is disabled. This prevents
# to react on other asynInt32::CmdReq requests. For some reason
# the excersize with DISV & SDIS in CmdRsp caches previous response
# and doesn't work as expected.
record(calcout, "$(P)CmdRspCalc")
{
    field(INPA, "$(P)CmdReq.DISP")
    field(INPB, "$(P)CmdRspRaw NPP")
    field(CALC, "A=1")
    field(OOPT, "When Non-zero")
    field(OCAL, "B")
    field(DOPT, "Use OCAL")
    field(OUT,  "$(P)CmdRsp PP")
}
record(mbbi, "$(P)CmdRsp")
{
    field(DESC, "Last command response")
    field(ZRVL, "0")
    field(ZRST, "None issued")
    field(ONVL, "1")
    field(ONST, "Success")
    field(TWVL, "2")
    field(TWST, "Waiting")
    field(THVL, "3")
    field(THST, "Timeout")
    field(FRVL, "4")
    field(FRST, "Error")
    field(FVVL, "5")
    field(FVST, "Skipped")
    field(FLNK, "$(P)CmdReqEn")
}
# Re-enable CmdReq as soon as leaving Waiting state
record(calcout, "$(P)CmdReqEn")
{
    field(INPA, "$(P)CmdRsp NPP")
    field(CALC, "A=2")
    field(OUT,  "$(P)CmdReq.DISP")
    field(OOPT, "When Zero")
    field(FLNK, "$(P)RspCheck")
}
record(fanout, "$(P)RspCheck")
{
    field(DESC, "Response check fanout")
    field(LNK1, "$(P)RspMissCount PP")
    field(LNK2, "$(P)HwStatus PP")
    field(LNK3, "$(P)AcquiringCalc PP")
    field(LNK4, "$(P)AcquiringCheck PP")
    # LNK5,LNK6 reserved for custom use by modules
}
# Monitor CmdReq for start/stop commands and set AcquireSet to yes/no
record(calcout, "$(P)AcquiringCalc")
{
    field(INPA, "$(P)CmdReq NPP")
    field(INPB, "$(P)CmdRsp NPP")
    field(CALC, "B=1&&(A=5||A=6)")
    field(OOPT, "When Non-zero")
    field(OCAL, "A=5")
    field(DOPT, "Use OCAL")
    field(OUT,  "$(P)AcquiringSet PP")
}
record(bi, "$(P)AcquiringSet")
{
    field(ZNAM, "not acquiring")
    field(ONAM, "acquiring")
    field(VAL,  "0")
    field(PINI, "YES")
    field(FLNK, "$(P)StatusCalc")
}
# Verifies that acquiring state matches the request
# 0 .. mismatch (MAJOR alarm)
# 1 .. not acquiring
# 2 .. acquiring
# When module is disabled, we follow the request
record(calc, "$(P)AcquiringCheckCalc")
{
    field(INPA, "$(P)Acquiring NPP")
    field(INPB, "$(P)AcquiringSet NPP")
    field(INPC, "$(P)Enable NPP")
    field(CALC, "(C=1&&A#B)?0:A+1")
    field(LOW,  "0")
    field(LSV,  "MAJOR")
}
record(mbbo, "$(P)AcquiringCheck")
{
    field(DOL,  "$(P)AcquiringCheckCalc PP")
    field(OMSL, "closed_loop")
    field(ZRVL, "0")
    field(ZRST, "mismatch")
    field(ZRSV, "MAJOR")
    field(ONVL, "1")
    field(ONST, "not acquiring")
    field(TWVL, "2")
    field(TWST, "acquiring")
    field(FLNK, "$(P)StatusCalc")
}
record(bi, "$(P)Acquiring")
{
    field(FLNK, "$(P)AcquiringCalc")
}
# Placeholder record, may be extended by module.
# MAJOR alarm is captured in overall status.
record(calc, "$(P)HwStatus")
{
    info(archive, "Monitor, 00:01:00, VAL")
    field(DESC, "Hardware status")
    field(FLNK, "$(P)StatusCalc")
}
# Detector is considered missing if it doesn't respond to at 2 or more
# subsequent commands. Record recoveres (goes out of alarm) if it responds
# afterwards.
record(calc, "$(P)RspMissCount")
{
    info(archive, "Monitor, 00:00:10, VAL")
    info(autosaveFields, "HIHI")
    field(DESC, "Count missing responses")
    field(INPA, "$(P)CmdRsp NPP")
    field(INPB, "$(P)RspMissCount NPP")
    field(INPC, "$(P)Enable NPP")
    field(CALC, "C=0?0:(A=3)?B+1:(A=2)?B:0")
    field(HIHI, "3")
    field(HHSV, "MAJOR")
    field(FLNK, "$(P)StatusCalc")
}
# All status logic tries to use 1 = OK, 0 = Not OK
# Summarize alarms.
record(calc, "$(P)HealthStatusCalc")
{
    field(DESC, "Aggregate alarms")
    field(INPA, "$(P)RspMissCount.SEVR")
    field(INPB, "$(P)Supported.SEVR")
    field(INPC, "$(P)Verified.SEVR")
    field(INPD, "$(P)HwStatus.SEVR")
    field(INPE, "$(P)Enable NPP")
    field(CALC, "(A+B+C+D)=0||E=0")
    field(LOW,  "0")
    field(LSV,  "MAJOR")
    field(PINI, "YES") # For Supported link
    field(FLNK, "$(P)StatusCalc")
}
record(calc, "$(P)StatusCalc")
{
    field(INPA, "$(P)Enable NPP")
    field(INPB, "$(P)HealthStatusCalc.SEVR PP")
    field(INPC, "$(P)AcquiringCheck.SEVR PP")
    field(CALC, "A=0||(B+C)=0")
    field(PINI, "YES") # For Supported link
    field(FLNK, "$(P)Status")
}
record(bi, "$(P)Status")
{
    info(archive, "Monitor, 00:00:10, VAL")
    field(ZNAM, "Not OK")
    field(ONAM, "OK")
    field(ZSV,  "MAJOR")
    field(INP,  "$(P)StatusCalc")
}
record(stringin, "$(P)HwDate")
{
    info(archive, "Monitor, 00:01:00, VAL")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT))HwDate")
    field(VAL,  "Unknown")
    field(SCAN, "I/O Intr")
}
record(longin, "$(P)HwRev")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))HwRev")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)HwVerStr")
    field(HSV,  "MAJOR")
    field(LSV,  "MAJOR")
}
record(longin, "$(P)HwVer")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))HwVer")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)HwVerStr")
    field(HSV,  "MAJOR")
    field(LSV,  "MAJOR")
}
record(scalcout, "$(P)HwVerStr")
{
    field(DESC, "HW version concatenated")
    field(INPA, "$(P)HwVer NPP MS")
    field(INPB, "$(P)HwRev NPP MS")
    field(CALC, "PRINTF('%i',A)+'.'+PRINTF('%i',B)")
}
record(stringin, "$(P)FwDate")
{
    info(archive, "Monitor, 00:01:00, VAL")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT))FwDate")
    field(VAL,  "Unknown")
    field(SCAN, "I/O Intr")
}
record(longin, "$(P)FwRev")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))FwRev")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)FwVerStr")
    field(HSV,  "MAJOR")
    field(LSV,  "MAJOR")
}
record(longin, "$(P)FwVer")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))FwVer")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)FwVerStr")
    field(HSV,  "MAJOR")
    field(LSV,  "MAJOR")
}
record(scalcout, "$(P)FwVerStr")
{
    info(archive, "Monitor, 00:01:00, VAL")
    field(DESC, "FW version concatenated")
    field(INPA, "$(P)FwVer NPP MS")
    field(INPB, "$(P)FwRev NPP MS")
    field(CALC, "PRINTF('%i',A)+'.'+PRINTF('%i',B)")
}
record(bi, "$(P)Supported")
{
    field(DESC, "Is module supported")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))Supported")
    field(SCAN, "Passive")
    field(PINI, "YES")
    field(ZNAM, "Not supported")
    field(ZSV,  "MAJOR")
    field(ONAM, "Supported")
}
record(mbbi, "$(P)Verified")
{
    field(DESC, "Conn,version,type verified")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))Verified")
    field(SCAN, "I/O Intr")
    field(ZRVL, "0")
    field(ZRST, "Not verified")
    field(ZRSV, "INVALID")
    field(ONVL, "1")
    field(ONST, "Type OK")
    field(ONSV, "MINOR")
    field(TWVL, "2")
    field(TWST, "Type mismatch")
    field(TWSV, "MAJOR")
    field(THVL, "4")
    field(THST, "Version OK")
    field(THSV, "MINOR")
    field(FRVL, "8")
    field(FRST, "Version mismatch")
    field(FRSV, "MAJOR")
    field(FVVL, "10") # b1010
    field(FVST, "Bad type & version")
    field(FVSV, "MAJOR")
    field(SXVL, "5") # b0101
    field(SXST, "Type & version OK")
    field(SXSV, "NO_ALARM")
    field(SVVL, "9") # b1001
    field(SVST, "Version mismatch")
    field(SVSV, "MAJOR")
    field(EIVL, "6") # b0110
    field(EIST, "Type mismatch")
    field(EISV, "MAJOR")
    field(FLNK, "$(P)StatusCalc")
}
record(mbbi, "$(P)HwType")
{
    field(DESC, "Module type")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))HwType")
    field(SCAN, "Passive")
    field(PINI, "YES")
    field(ZRVL, "32")
    field(ONVL, "33")
    field(TWVL, "34")
    field(THVL, "37")
    field(FRVL, "41")
    field(FVVL, "42")
    field(SXVL, "43")
    field(SVVL, "48")
    field(EIVL, "64")
    field(NIVL, "160")
    field(TEVL, "161")
    field(ELVL, "162")
    field(TVVL, "170")
    field(TTVL, "45")
    field(ZRST, "ROC")
    field(ONST, "AROC")
    field(TWST, "HROC")
    field(THST, "BNLROC")
    field(FRST, "CROC")
    field(FVST, "IROC")
    field(SXST, "BIDIM ROC")
    field(SVST, "DSP")
    field(EIST, "SANS ROC")
    field(NIST, "ACPC")
    field(TEST, "ACPC FEM")
    field(ELST, "FFC")
    field(TVST, "FEM")
    field(TTST, "ADCROC")
}
record(mbbo, "$(P)CfgSection")
{
    field(DESC, "Config section to write")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))CfgSection")
    field(PINI, "YES")
    field(ZRVL, "0")
    field(ZRST, "Full config")
    field(ONVL, "1")
    field(ONST, "Section 1")
    field(TWVL, "2")
    field(TWST, "Section 2")
    field(THVL, "3")
    field(THST, "Section 3")
    field(FRVL, "4")
    field(FRST, "Section 4")
    field(FVVL, "5")
    field(FVST, "Section 5")
    field(SXVL, "6")
    field(SXST, "Section 6")
    field(SVVL, "7")
    field(SVST, "Section 7")
    field(EIVL, "8")
    field(EIST, "Section 8")
    field(NIVL, "9")
    field(NIST, "Section 9")
    field(TEVL, "10")
    field(TEST, "Section A")
    field(ELVL, "11")
    field(ELST, "Section B")
    field(TVVL, "12")
    field(TVST, "Section C")
    field(TTVL, "13")
    field(TTST, "Section D")
    field(FTVL, "14")
    field(FTST, "Section E")
    field(FFVL, "15")
    field(FFST, "Section F")
}
record(mbbi, "$(P)CfgChannel")
{
    field(DESC, "Selected config channel")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))CfgChannel")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
    field(VAL,  "0")
    field(ZRVL, "0")
    field(ZRST, "Main")
}
record(mbbi, "$(P)UpgradeStatus")
{
    field(DESC, "Remote upgrade status")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))UpgradeStatus")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
    field(ZRVL, "0")
    field(ZRST, "Not supported")
    field(ONVL, "1")
    field(ONST, "Not started")
    field(TWVL, "2")
    field(TWST, "In progress")
    field(THVL, "3")
    field(THST, "Complete")
    field(FRVL, "4")
    field(FRST, "Canceled")
    field(FVVL, "5")
    field(FVST, "Init failed")
    field(SXVL, "5")
    field(SXST, "User aborted")
}
record(longin, "$(P)UpgradeSize")
{
    field(DESC, "Total firmware size in bytes")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))UpgradeSize")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
    field(EGU,  "B")
}
record(longin, "$(P)UpgradePos")
{
    field(DESC, "Bytes sent to remote party")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))UpgradePos")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
    field(EGU,  "B")
}
record(longout, "$(P)UpgradePktSize")
{
    field(DESC, "Number of bytes per packet")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))UpgradePktSize")
    field(EGU,  "B")
    field(ASG,  "BEAMLINE")
}
record(longin, "$(P)UpgradePktSize_RBV")
{
    field(DESC, "RB Number of bytes per packet")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))UpgradePktSize")
    field(EGU,  "B")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
}
record(waveform, "$(P)UpgradeFile")
{
    field(DESC, "New firmware file to be programed")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn($(PORT))UpgradeFile")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(ASG,  "BEAMLINE")
}
record(bo, "$(P)UpgradeAbort")
{
    field(DESC, "Abort current upgrade sequence")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))UpgradeAbort")
    field(ASG,  "BEAMLINE")
    field(ZNAM, "No action")
    field(ONAM, "Abort")
}
# Periodic .5 second sseq record serializes processing of user configurable
# periodic records. When run in parallel they would fight for CmdReq, where
# only one request can be on-going until response is received.
# *Refresh records heavily depend on SCAN period to be .5 second.
record(sseq, "$(P)PeriodicCheckUp")
{
    field(DESC,  "Periodic check fanout")
    field(SCAN,  ".5 second")
    field(DOL1,  "1")
    field(DOL2,  "1")
    field(DOL3,  "1")
    field(LNK1,  "$(P)StatusRefresh.PROC CA")
    field(LNK2,  "$(P)CountersRefresh.PROC CA")
    field(LNK3,  "$(P)TempRefresh.PROC CA")
    field(WAIT1, "Wait")
    field(WAIT2, "Wait")
    field(WAIT3, "Wait")
    field(SDIS, "$(P)Enable NPP") # Don't run if disabled
    field(DISV, "0")
}
record(longin, "$(P)StatusRefreshInt")
{
    info(autosaveFields, "VAL")
    field(DESC, "Periodically update status interval")
    field(FLNK, "$(P)StatusRefresh PP")
    field(PINI, "YES")
    field(VAL,  "0") # Refresh interval in seconds, 0 to disable
    field(EGU,  "seconds")
}
record(calcout, "$(P)StatusRefresh")
{
    field(DESC, "Periodically update status")
    field(ASG,  "BEAMLINE")
    field(INPA, "$(P)StatusRefreshInt NPP")
    field(INPB, "$(P)StatusRefresh NPP")
    field(INPC, "$(P)CmdRsp NPP")
    # Possibly delays Transition To Zero for 2 seconds if CmdRsp=Waiting
    field(CALC, "(C=2||A=0||((B+1)<(2*A)))?B+1:0")
    field(OCAL, "2") # Send Read status
    field(OUT,  "$(P)CmdReq PP")
    field(OOPT, "Transition To Zero")
    field(DOPT, "Use OCAL")
}
record(longout, "$(P)CountersRefreshInt")
{
    info(autosaveFields, "VAL")
    field(DESC, "Periodically update counters interval")
    field(FLNK, "$(P)CountersRefresh PP")
    field(PINI, "YES")
    field(VAL,  "0") # Refresh interval in seconds, 0 to disable
    field(EGU,  "seconds")
}
record(calcout, "$(P)CountersRefresh")
{
    info(autosaveFields, "INPA")
    field(DESC, "Periodically update counters")
    field(ASG,  "BEAMLINE")
    field(INPA, "$(P)CountersRefreshInt NPP")
    field(INPB, "$(P)CountersRefresh NPP")
    field(INPC, "$(P)CmdRsp NPP")
    # Possibly delay Transition To Zero for 1 second if CmdRsp=Waiting
    field(CALC, "(C=2||A=0||((B+1)<(2*A)))?B+1:0")
    field(OCAL, "7") # Send Read counters
    field(OUT,  "$(P)CmdReq PP")
    field(OOPT, "Transition To Zero")
    field(DOPT, "Use OCAL")
}
record(longout, "$(P)TempRefreshInt")
{
    info(autosaveFields, "VAL")
    field(DESC, "Periodically update temp. interval")
    field(FLNK, "$(P)TempRefresh PP")
    field(PINI, "YES")
    field(VAL,  "0") # Refresh interval in seconds, 0 to disable. Override in modules which support it
    field(EGU,  "seconds")
}
record(calcout, "$(P)TempRefresh")
{
    field(DESC, "Periodically update temperatures")
    field(ASG,  "BEAMLINE")
    field(INPA, "$(P)TempRefreshInt NPP")
    field(INPB, "$(P)TempRefresh NPP")
    field(INPC, "$(P)CmdRsp NPP")
    # Possibly delay Transition To Zero for 1 second if CmdRsp=Waiting
    field(CALC, "(C=2||A=0||((B+1)<(2*A)))?B+1:0")
    field(OCAL, "9") # Send Read temperatures
    field(OUT,  "$(P)CmdReq PP")
    field(OOPT, "Transition To Zero")
    field(DOPT, "Use OCAL")
}
record(ao, "$(P)NoRspTimeout")
{
    field(DESC, "Time to wait for response")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT))NoRspTimeout")
    field(EGU,  "seconds")
    field(PREC, "1")
}
