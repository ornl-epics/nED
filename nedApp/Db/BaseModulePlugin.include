record(bo, "$(P)Enable")
{
    field(FLNK, "$(P)StatusCalc")
}
record(stringin, "$(P)HwId")
{
    field(DESC, "Hardware ID address")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT))HwId")
    field(SCAN, "Passive")
    field(PINI, "YES")
}
record(mbbo, "$(P)CmdReq")
{
    field(ASG,  "BEAMLINE")
    field(DESC, "Send command to module")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))CmdReq")
    field(ZRVL, "129")
    field(ZRST, "Reset")
    field(ONVL, "128")
    field(ONST, "Discover")
    field(TWVL, "32")
    field(TWST, "Read version")
    field(THVL, "34")
    field(THST, "Read status")
    field(FRVL, "33")
    field(FRST, "Read config")
    field(FVVL, "48")
    field(FVST, "Write config")
    field(SXVL, "130")
    field(SXST, "Start acquisition")
    field(SVVL, "131")
    field(SVST, "Stop acquisition")
    field(EIVL, "36")
    field(EIST, "Read counters")
    field(NIVL, "37")
    field(NIST, "Reset counters")
    field(TEVL, "111")
    field(TEST, "Upgrade")
    field(ELVL, "35")
    field(ELST, "Read temperature")
    field(FLNK, "$(P)CmdRspEnable")
}
# This CmdRsp* database logic is used to split set of CmdReq/CmdRsp asyn hooks into
# multiple PVs. Not all modules provide all commands but they would all like to use
# the same interface (for C code simplicity). We use a trick in CmdReq to only enable
# CmdRsp PV when actually expecting something. Different set of PVs can be used
# for specialized commands, although there might race condition if more than one PV
# connected to asyn(CmdReq) is used at the same time. Though the worst case is that
# CmdRsp gets false response.
record(longout, "$(P)CmdRspEnable")
{
    field(DOL,  "1")
    field(OUT,  "$(P)CmdRspEn PP")
}
record(calcout, "$(P)CmdRspDisable")
{
    field(INPA, "$(P)CmdRspRaw PP")
    field(CALC, "A=0||A=2")
    field(OOPT, "When Zero")
    field(OUT,  "$(P)CmdRspEn PP")
}
record(bi, "$(P)CmdRspEn")
{
    field(ZNAM, "CmdRsp disabled")
    field(ONAM, "CmdRsp enabled")
    field(VAL,  "0")
    field(PINI, "YES")
}
record(longin, "$(P)CmdRspRaw")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))CmdRsp")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)CmdRspFilter")
}
record(calcout, "$(P)CmdRspFilter")
{
    field(INPA, "$(P)CmdRspEn NPP")
    field(CALC, "A=1")
    field(OOPT, "When Non-zero")
    field(OUT,  "$(P)CmdRspFanout PP")
}
record(fanout, "$(P)CmdRspFanout")
{
    field(LNK1, "$(P)CmdRspDisable PP")
    field(LNK2, "$(P)CmdRsp PP")
}
record(mbbi, "$(P)CmdRsp")
{
    field(DESC, "Last command response")
    field(INP,  "$(P)CmdRspRaw NPP")
    field(FLNK, "$(P)RspCheck")
    field(ZRVL, "0")
    field(ZRST, "None issued")
    field(ONVL, "1")
    field(ONST, "Success")
    field(TWVL, "2")
    field(TWST, "Waiting")
    field(THVL, "3")
    field(THST, "Timeout")
    field(FRVL, "4")
    field(FRST, "Error")
    field(FVVL, "5")
    field(FVST, "Skipped")
}
record(fanout, "$(P)RspCheck")
{
    field(DESC, "Response check fanout")
    field(LNK1, "$(P)MissCount PP")
    field(LNK2, "$(P)HwStatus PP")
    field(LNK3, "$(P)AcquiringCalc PP")
}
# Monitor CmdReq for start/stop commands and set AcquireSet to yes/no
record(calcout, "$(P)AcquiringCalc")
{
    field(INPA, "$(P)CmdReq NPP")
    field(INPB, "$(P)CmdRsp NPP")
    field(CALC, "B=1&&(A=6||A=7)")
    field(OOPT, "When Non-zero")
    field(OCAL, "A=6")
    field(DOPT, "Use OCAL")
    field(OUT,  "$(P)AcquiringSet PP")
}
record(bi, "$(P)AcquiringSet")
{
    field(ZNAM, "not acquiring")
    field(ONAM, "acquiring")
    field(FLNK, "$(P)AcquiringCheck")
}
record(calc, "$(P)AcquiringCheck")
{
    field(INPA, "$(P)Acquiring NPP")
    field(INPB, "$(P)AcquiringSet NPP")
    field(INPC, "$(P)AcquiringSet.SEVR NPP")
    field(CALC, "A=B&&C=0")
    field(LOW,  "0")
    field(LSV,  "MAJOR")
    field(FLNK, "$(P)StatusCalc")
}
record(bi, "$(P)Acquiring")
{
    field(FLNK, "$(P)AcquiringCheck")
}
# Placeholder record, may be extended by module.
# MAJOR alarm is captured in overall status.
record(calc, "$(P)HwStatus")
{
    info(archive, "Monitor, 00:01:00, VAL")
    field(DESC, "Hardware status")
    field(FLNK, "$(P)StatusCalc")
}
# Detector is considered missing if it doesn't respond to at 2 or more
# subsequent commands. Record recoveres (goes out of alarm) if it responds
# afterwards.
record(calc, "$(P)MissCount")
{
    info(archive, "Monitor, 00:00:10, VAL")
    field(DESC, "Count missing responses")
    field(INPA, "$(P)CmdRsp NPP")
    field(INPB, "$(P)MissCount NPP")
    field(INPC, "$(P)Enable NPP")
    field(CALC, "C=0?0:(A=3)?B+1:(A=2)?B:0")
    field(HIGH, "3")
    field(HSV,  "MINOR")
    field(HIHI, "5")
    field(HHSV, "MAJOR")
    field(FLNK, "$(P)StatusCalc")
}
# All status logic tries to use 1 = OK, 0 = Not OK
# Summarize alarms.
record(calc, "$(P)HealthStatusCalc")
{
    field(DESC, "Aggregate alarms")
    field(INPA, "$(P)MissCount.SEVR")
    field(INPB, "$(P)Supported.SEVR")
    field(INPC, "$(P)Verified.SEVR")
    field(INPD, "$(P)HwStatus.SEVR")
    field(INPE, "$(P)Enable NPP")
    field(CALC, "(A+B+C+D)=0||E=0")
    field(LOW,  "0")
    field(LSV,  "MAJOR")
    field(PINI, "YES") # For Supported link
    field(FLNK, "$(P)StatusCalc")
}
record(calc, "$(P)StatusCalc")
{
    field(INPA, "$(P)Enable NPP")
    field(INPB, "$(P)HealthStatusCalc.SEVR PP")
   field(INPC, "$(P)AcquiringCheck.SEVR NPP")
    field(CALC, "A=0||(B+C)=0")
    field(PINI, "YES") # For Supported link
    field(FLNK, "$(P)Status")
}
record(bi, "$(P)Status")
{
    info(archive, "Monitor, 00:00:10, VAL")
    field(ZNAM, "Not OK")
    field(ONAM, "OK")
    field(ZSV,  "MAJOR")
    field(INP,  "$(P)StatusCalc")
}
record(stringin, "$(P)HwDate")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT))HwDate")
    field(VAL,  "Unknown")
    field(SCAN, "I/O Intr")
}
record(longin, "$(P)HwRev")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))HwRev")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)HwVerStr")
    field(HSV,  "MAJOR")
    field(LSV,  "MAJOR")
}
record(longin, "$(P)HwVer")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))HwVer")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)HwVerStr")
    field(HSV,  "MAJOR")
    field(LSV,  "MAJOR")
}
record(scalcout, "$(P)HwVerStr")
{
    field(DESC, "HW version concatenated")
    field(INPA, "$(P)HwVer NPP MS")
    field(INPB, "$(P)HwRev NPP MS")
    field(CALC, "PRINTF('%i',A)+'.'+PRINTF('%i',B)")
}
record(stringin, "$(P)FwDate")
{
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT))FwDate")
    field(VAL,  "Unknown")
    field(SCAN, "I/O Intr")
}
record(longin, "$(P)FwRev")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))FwRev")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)FwVerStr")
    field(HSV,  "MAJOR")
    field(LSV,  "MAJOR")
}
record(longin, "$(P)FwVer")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))FwVer")
    field(VAL,  "0")
    field(SCAN, "I/O Intr")
    field(FLNK, "$(P)FwVerStr")
    field(HSV,  "MAJOR")
    field(LSV,  "MAJOR")
}
record(scalcout, "$(P)FwVerStr")
{
    field(DESC, "FW version concatenated")
    field(INPA, "$(P)FwVer NPP MS")
    field(INPB, "$(P)FwRev NPP MS")
    field(CALC, "PRINTF('%i',A)+'.'+PRINTF('%i',B)")
}
record(bi, "$(P)Supported")
{
    field(DESC, "Is module supported")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))Supported")
    field(SCAN, "Passive")
    field(PINI, "YES")
    field(ZNAM, "Not supported")
    field(ZSV,  "MAJOR")
    field(ONAM, "Supported")
}
record(mbbi, "$(P)Verified")
{
    field(DESC, "Conn,version,type verified")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))Verified")
    field(SCAN, "I/O Intr")
    field(ZRVL, "0")
    field(ZRST, "Not verified")
    field(ZRSV, "INVALID")
    field(ONVL, "1")
    field(ONST, "Type OK")
    field(ONSV, "MINOR")
    field(TWVL, "2")
    field(TWST, "Type mismatch")
    field(TWSV, "MAJOR")
    field(THVL, "4")
    field(THST, "Version OK")
    field(THSV, "MINOR")
    field(FRVL, "8")
    field(FRST, "Version mismatch")
    field(FRSV, "MAJOR")
    field(FVVL, "10") # b1010
    field(FVST, "Bad type & version")
    field(FVSV, "MAJOR")
    field(SXVL, "5") # b0101
    field(SXST, "Type & version OK")
    field(SXSV, "NO_ALARM")
    field(SVVL, "9") # b1001
    field(SVST, "Version mismatch")
    field(SVSV, "MAJOR")
    field(EIVL, "6") # b0110
    field(EIST, "Type mismatch")
    field(EISV, "MAJOR")
    field(FLNK, "$(P)StatusCalc")
}
record(mbbi, "$(P)HwType")
{
    field(DESC, "Module type")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))HwType")
    field(SCAN, "Passive")
    field(PINI, "YES")
    field(ZRVL, "32")
    field(ONVL, "33")
    field(TWVL, "34")
    field(THVL, "37")
    field(FRVL, "41")
    field(FVVL, "42")
    field(SXVL, "43")
    field(SVVL, "48")
    field(EIVL, "64")
    field(NIVL, "160")
    field(TEVL, "161")
    field(ELVL, "162")
    field(TVVL, "170")
    field(TTVL, "45")
    field(ZRST, "ROC")
    field(ONST, "AROC")
    field(TWST, "HROC")
    field(THST, "BLN ROC")
    field(FRST, "CROC")
    field(FVST, "IROC")
    field(SXST, "BIDIM ROC")
    field(SVST, "DSP")
    field(EIST, "SANS ROC")
    field(NIST, "ACPC")
    field(TEST, "ACPC FEM")
    field(ELST, "FFC")
    field(TVST, "FEM")
    field(TTST, "ADCROC")
}
record(mbbo, "$(P)CfgSection")
{
    field(DESC, "Config section to write")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))CfgSection")
    field(PINI, "YES")
    field(ZRVL, "0")
    field(ZRST, "Full config")
    field(ONVL, "1")
    field(ONST, "Section 1")
    field(TWVL, "2")
    field(TWST, "Section 2")
    field(THVL, "3")
    field(THST, "Section 3")
    field(FRVL, "4")
    field(FRST, "Section 4")
    field(FVVL, "5")
    field(FVST, "Section 5")
    field(SXVL, "6")
    field(SXST, "Section 6")
    field(SVVL, "7")
    field(SVST, "Section 7")
    field(EIVL, "8")
    field(EIST, "Section 8")
    field(NIVL, "9")
    field(NIST, "Section 9")
    field(TEVL, "10")
    field(TEST, "Section A")
    field(ELVL, "11")
    field(ELST, "Section B")
    field(TVVL, "12")
    field(TVST, "Section C")
    field(TTVL, "13")
    field(TTST, "Section D")
    field(FTVL, "14")
    field(FTST, "Section E")
    field(FFVL, "15")
    field(FFST, "Section F")
}
record(mbbi, "$(P)CfgChannel")
{
    field(DESC, "Selected config channel")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))CfgChannel")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
    field(VAL,  "0")
    field(ZRVL, "0")
    field(ZRST, "Main")
}
record(mbbi, "$(P)UpgradeStatus")
{
    field(DESC, "Remote upgrade status")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))UpgradeStatus")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
    field(ZRVL, "0")
    field(ZRST, "Not supported")
    field(ONVL, "1")
    field(ONST, "Not started")
    field(TWVL, "2")
    field(TWST, "In progress")
    field(THVL, "3")
    field(THST, "Complete")
    field(FRVL, "4")
    field(FRST, "Canceled")
    field(FVVL, "5")
    field(FVST, "Init failed")
    field(SXVL, "5")
    field(SXST, "User aborted")
}
record(longin, "$(P)UpgradeSize")
{
    field(DESC, "Total firmware size in bytes")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))UpgradeSize")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
    field(EGU,  "B")
}
record(longin, "$(P)UpgradePos")
{
    field(DESC, "Bytes sent to remote party")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))UpgradePos")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
    field(EGU,  "B")
}
record(longout, "$(P)UpgradePktSize")
{
    field(DESC, "Number of bytes per packet")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))UpgradePktSize")
    field(EGU,  "B")
    field(ASG,  "BEAMLINE")
}
record(longin, "$(P)UpgradePktSize_RBV")
{
    field(DESC, "RB Number of bytes per packet")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT))UpgradePktSize")
    field(EGU,  "B")
    field(SCAN, "I/O Intr")
    field(PINI, "YES")
}
record(waveform, "$(P)UpgradeFile")
{
    field(DESC, "New firmware file to be programed")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn($(PORT))UpgradeFile")
    field(FTVL, "CHAR")
    field(NELM, "1024")
    field(ASG,  "BEAMLINE")
}
record(bo, "$(P)UpgradeAbort")
{
    field(DESC, "Abort current upgrade sequence")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT))UpgradeAbort")
    field(ASG,  "BEAMLINE")
    field(ZNAM, "No action")
    field(ONAM, "Abort")
}
# Periodic .5 second sseq record serializes processing of user configurable
# periodic records. When run in parallel they would fight for CmdReq, where
# only one request can be on-going until response is received.
# *Refresh records heavily depend on SCAN period to be .5 second.
record(sseq, "$(P)PeriodicCheckUp")
{
    field(DESC,  "Periodic check fanout")
    field(SCAN,  ".5 second")
    field(DOL1,  "1")
    field(DOL2,  "1")
    field(DOL3,  "1")
    field(LNK1,  "$(P)StatusRefresh.PROC CA")
    field(LNK2,  "$(P)CountersRefresh.PROC CA")
    field(LNK3,  "$(P)TempRefresh.PROC CA")
    field(WAIT1, "Wait")
    field(WAIT2, "Wait")
    field(WAIT3, "Wait")
    field(SDIS, "$(P)Enable NPP") # Don't run if disabled
    field(DISV, "0")
}
record(longin, "$(P)StatusRefreshInt")
{
    info(autosaveFields, "VAL")
    field(DESC, "Periodically update status interval")
    field(FLNK, "$(P)StatusRefresh PP")
    field(PINI, "YES")
    field(VAL,  "0") # Refresh interval in seconds, 0 to disable
    field(EGU,  "seconds")
}
record(calcout, "$(P)StatusRefresh")
{
    field(DESC, "Periodically update status")
    field(ASG,  "BEAMLINE")
    field(INPA, "$(P)StatusRefreshInt NPP")
    field(INPB, "$(P)StatusRefresh NPP")
    field(INPC, "$(P)CmdRsp NPP")
    # Possibly delays Transition To Zero for 2 seconds if CmdRsp=Waiting
    field(CALC, "(C=2||A=0||((B+1)<(2*A)))?B+1:0")
    field(OCAL, "3") # Send Read status
    field(OUT,  "$(P)CmdReq PP")
    field(OOPT, "Transition To Zero")
    field(DOPT, "Use OCAL")
}
record(longout, "$(P)CountersRefreshInt")
{
    info(autosaveFields, "VAL")
    field(DESC, "Periodically update counters interval")
    field(FLNK, "$(P)CountersRefresh PP")
    field(PINI, "YES")
    field(VAL,  "0") # Refresh interval in seconds, 0 to disable
    field(EGU,  "seconds")
}
record(calcout, "$(P)CountersRefresh")
{
    info(autosaveFields, "INPA")
    field(DESC, "Periodically update counters")
    field(ASG,  "BEAMLINE")
    field(INPA, "$(P)CountersRefreshInt NPP")
    field(INPB, "$(P)CountersRefresh NPP")
    field(INPC, "$(P)CmdRsp NPP")
    # Possibly delay Transition To Zero for 1 second if CmdRsp=Waiting
    field(CALC, "(C=2||A=0||((B+1)<(2*A)))?B+1:0")
    field(OCAL, "8") # Send Read counters
    field(OUT,  "$(P)CmdReq PP")
    field(OOPT, "Transition To Zero")
    field(DOPT, "Use OCAL")
}
record(longout, "$(P)TempRefreshInt")
{
    info(autosaveFields, "VAL")
    field(DESC, "Periodically update temp. interval")
    field(FLNK, "$(P)TempRefresh PP")
    field(PINI, "YES")
    field(VAL,  "0") # Refresh interval in seconds, 0 to disable. Override in modules which support it
    field(EGU,  "seconds")
}
record(calcout, "$(P)TempRefresh")
{
    field(DESC, "Periodically update temperatures")
    field(ASG,  "BEAMLINE")
    field(INPA, "$(P)TempRefreshInt NPP")
    field(INPB, "$(P)TempRefresh NPP")
    field(INPC, "$(P)CmdRsp NPP")
    # Possibly delay Transition To Zero for 1 second if CmdRsp=Waiting
    field(CALC, "(C=2||A=0||((B+1)<(2*A)))?B+1:0")
    field(OCAL, "11") # Send Read temperatures
    field(OUT,  "$(P)CmdReq PP")
    field(OOPT, "Transition To Zero")
    field(DOPT, "Use OCAL")
}
record(ao, "$(P)NoRspTimeout")
{
    field(DESC, "Time to wait for response")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT))NoRspTimeout")
    field(EGU,  "seconds")
    field(PREC, "1")
}
